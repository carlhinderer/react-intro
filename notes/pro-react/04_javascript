-----------------------------------------------------------
CHAPTER 4 - JAVASCRIPT
-----------------------------------------------------------

- Creating Project

    - JavaScript has been modernized in recent years with the addition of new language
        features and utility functions.  

      Since not all browsers support the latest features, React includes the Babel package,
        which will translate these features into code that will work in most mainstream
        browsers.


    - We'll keep using the 'primer' project from Chapter 3.  First, we'll create a new file
        for testing things out.

        # File: src/example.js
        console.log("Hello");


    - And, we'll need to add our new file to incorporate it into the application.

        # Add to src/index.js after other imports
        import "./example";


    - Start the application.

        $ npm start

      Now, open the Developer Tools in your web browser, and should see the 'Hello' printed.



- Using Statements

    - Statement-terminating semicolons are optional, but adding them makes code more readable
        and allows multiple statements on a single line.


    - Syntax warnings received when a React project is built come from the 'ESLint' package.



- Defining and Using Functions

    - To define a function:

        const myFunc = function () {
            console.log('Inside the function.');
        }

        myFunc();


    - Define a function without explicitly defining a variable.

        function myFunc() {
            console.log('Inside the function');
        }

        myFunc();



- Defining Functions With Parameters

    - To define parameters for functions:

        function myFunc(name, weather) {
            console.log("Hello " + name + ".");
            console.log("It is " + weather + " today.");
        }

        myFunc("Adam", "sunny");


    - If you call the function with fewer arguments than it has parameters, the values of
        parameters not passed is 'undefined'.  If you call the function with extra arguments, 
        they are ignored.

      To add default values for parameters,

        function myFunc(name, weather = "raining") {
            console.log("Hello " + name + ".");
            console.log("It is " + weather + " today.");
        }

        myFunc("Adam"); 


    - 'Rest parameters' are used to capture any additional arguments when a function is invoked
        with additional arguments.

        function myFunc(name, weather, ...extraArgs) {
            console.log("Hello " + name + ".");
            console.log("It is " + weather + " today.");
            for (let i = 0; i < extraArgs.length; i++) {
                console.log("Extra Arg: " + extraArgs[i]);
            }
        }

        myFunc("Adam", "sunny", "one", "two", "three");



- Defining Functions That Return Results

    - The 'return' keyword is used to return results.  If no return statement is included, 
        'undefined' is returned from the function.

         function myFunc(name) {
             return ("Hello " + name + ".");
         }

         console.log(myFunc("Adam")); 



- Using Functions as Arguments to Other Functions

    - JavaScript functions can be treated as objects, which means one function can be
        used as an argument to another.

        function myFunc(nameFunction) {
            return ("Hello " + nameFunction() + ".");
        }

        function printName(nameFunction, printFunction) {
            printFunction(myFunc(nameFunction));
        }

        printName(function () { return "Adam" }, console.log);



- Using Arrow Functions

    - Arrow functions (aka 'fat arrow functions' or 'lambda expressions') are another way
        to define functions, usually functions that are arguments to other functions.

        const myFunc = (nameFunction) => ("Hello " + nameFunction() + ".");

        const printName = (nameFunction, printFunction) =>
            printFunction(myFunc(nameFunction));

        printName(function () { return "Adam" }, console.log);


    - The input parameters are in the parentheses, and the result of the statement after the arrow
        is returned from the function.

      The 'return' keyword and {} are only required if the arrow function needs to execute more
        than one statement.



- Using Variables and Types

    - The 'let' statement is used to declare variables that can change.
      The 'const' statement is used to create constants that cannot be modified.

      The 'var' statement is now deprecated, but still often used.


    - For an illustration of why the 'let' keyword was introduced to replace 'var',

        1. Use let, which has block scope.

             function messageFunction(name, weather) {
                 let message = "Hello, Adam";
                 if (weather === "sunny") {
                     let message = "It is a nice day";
                     console.log(message);
                 } else {
                     let message = "It is " + weather + " today";
                     console.log(message);
                 }
                 console.log(message);
             }

             messageFunction("Adam", "raining");

             # Results
             It is raining today
             Hello, Adam


        2. Use var, which scopes variables to the containing function.  This leads to some very
             confusing bugs, even for experienced JavaScript developers.

             function messageFunction(name, weather) {
                 var message = "Hello, Adam";
                 if (weather === "sunny") {
                     var message = "It is a nice day";
                     console.log(message);
                 } else {
                     var message = "It is " + weather + " today";
                     console.log(message);
                 }
                 console.log(message);
             }

             messageFunction("Adam", "raining");
             
             # Results
             It is raining today
             It is raining today



- Using Variable Closure

    - If you define a function inside of another function, then the inner function is able to 
        access the outer function's variables.  This feature is called a 'closure'.

        function myFunc(name) {
            let myLocalVar = "sunny";
            let innerFunction = function () {
                return ("Hello " + name + ". Today is " + myLocalVar + ".");
            }
            return innerFunction();
        }

        console.log(myFunc('Adam'));


    - This is a powerful feature that means you don't have to define parameters on inner functions
        to pass around data values, but caution is required.



- Using the Primitive Types

    - Booleans

        # Declare bools
        let firstBool = true;
        let secondBool = false;


    - Strings

        # Declare strings
        let firstString = "this is a string";
        let secondString = "this is also a string";

        # String length
        firstString.length

        # Common string methods
        charAt(index)
        concat(string)
        indexOf(term, start)
        replace(term, newTerm)
        slice(start, end)
        split(term)
        toUpperCase()
        toLowerCase()
        trim() 


    - Template Strings

        # Template strings are between backticks
        let message = `It is ${weather} today.`;


    - Numbers

        # The number type is used to represent both int and floating point
        let daysInWeek = 7;
        let pi = 3.14;
        let hexValue = 0xFFFF;



- Operators

    Operator                Description
    ---------------------------------------------------------------------------------
    ++, --                  Pre- or post-increment and decrement

    +, -, *, /, %           Addition, subtraction, multiplication, division, remainder

    <, <=, >, >=            Less than, less than or equal to, more than, more than or equal to

    ==, !=                  Equality and inequality tests

    ===, !==                Identity and nonidentity tests

    &&, ||                  Logical AND and OR (|| is used to coalesce null values)

    =                       Assignment

    +                       String concatenation

    ?:                      Three-operand conditional statement



- Conditionals

    - Here is an if/else statement:

        let name = "Adam";

        if (name === "Adam") {
            console.log("Name is Adam");
        } else if (name === "Jacqui") {
            console.log("Name is Jacqui");
        } else {
            console.log("Name is neither Adam or Jacqui");
        }


    - Here is a switch/case:

        switch (name) {
            case "Adam":
                console.log("Name is Adam");
                break;
            case "Jacqui":
                console.log("Name is Jacqui");
                break;
            default:
                console.log("Name is neither Adam or Jacqui");
                break;
        }



- The Equality and Identity Operators

- Explicitly Converting Types

- Working With Arrays

- Reading and Modifying Arrays

- Enumerating the Contents of an Array

- Using the Spread Operator

- Using the Built-in Array Methods

- Working With Objects

- Using Object Literals

- Using Variables as Object Properties

- Using Functions as Methods

- Using Classes

- Copying Properties From One Object to Another

- Capturing Parameter Names From Objects

- Creating and Using a JavaScript Module

- Understanding Module Locations

- Exporting Named Features From a Module

- Defining Multiple Named Features in a Module

- Changing Module Feature Names

- Importing an Entire Module

- Understanding the Asynchronous Operation Problem

- Using a JavaScript Promise

- Simplifying the Asynchronous Code
